{"ast":null,"code":"var _jsxFileName = \"/home/abbas/jsPractice/tasks/drinks-app/client/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport throttle from 'lodash.throttle';\nimport './App.css';\nimport endpoints from './api/endpoints';\nimport Header from './components/Header';\nimport BodyWrapper from './components/BodyWrapper';\nimport Filters from './components/Filters';\nimport Content from './components/Content';\n\nfunction App() {\n  //Filters set for the checkboxes\n  const [filters, setFilters] = useState([]); //All categories and drinks\n\n  const [drinks, setDrinks] = useState([]);\n  const [currentPage, setCurrentPage] = useState(0); //Filtered and paginated content that user sees\n\n  const [currentContent, setCurrentContent] = useState([]); //Update content when page scrolled to the end\n  //I see that this is unaccurate way to do updading \n  //but i hadn't mush time at the moment\n\n  const updateContent = throttle(() => {\n    let updating = true;\n    if (window.scrollY === 75) updating = true;\n\n    if (window.scrollY + window.innerHeight === document.body.clientHeight) {\n      if (updating) {\n        window.scrollTo({\n          top: 0,\n          behavior: 'smooth'\n        });\n        setCurrentPage(prevPage => prevPage + 1);\n        updating = false;\n      }\n    }\n\n    ;\n  }, 1500); //Runs at the first render and fetches all categories\n  //and drinks from api\n\n  useEffect(() => {\n    setInitialState();\n    window.addEventListener('scroll', updateContent);\n    return () => {\n      window.removeEventListener('scroll', updateContent);\n    };\n  }, []); //Checks the currentPage state and defines nex content\n\n  useEffect(() => {\n    //Check the last page and if true - return to the first one\n    if (currentPage > 10) setCurrentPage(1);\n    defineCurrentContent();\n  }, [currentPage]);\n  return React.createElement(\"div\", {\n    className: \"App\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 50\n    },\n    __self: this\n  }, React.createElement(Header, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51\n    },\n    __self: this\n  }), React.createElement(BodyWrapper, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52\n    },\n    __self: this\n  }, React.createElement(Filters, {\n    filters: drinks.map(category => category.filter),\n    applyFiltersHandler: applyFiltersHandler,\n    toggleFilterHandler: toggleFilterHandler,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53\n    },\n    __self: this\n  }), React.createElement(Content, {\n    drinks: currentContent,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57\n    },\n    __self: this\n  }))); //Set initial state at the first render\n\n  async function setInitialState() {\n    //To get access to the fetched filters at the nex chains\n    let filtersArray;\n    fetch(endpoints.filters).then(responce => responce.json()).then(array => {\n      setFilters(array.drinks.map(filter => filter.strCategory));\n      filtersArray = array.drinks;\n      return array;\n    }).then(categories => {\n      const drinksPromises = [];\n\n      for (let category of categories.drinks) {\n        drinksPromises.push(fetch(endpoints.drinks(category.strCategory)));\n      }\n\n      ;\n      return Promise.all(drinksPromises);\n    }).then(drinksPromices => {\n      return Promise.all(drinksPromices.map(prom => prom.json()));\n    }).then(drinksArray => {\n      const initialState = drinksArray.map((drinks, index) => {\n        return {\n          filter: filtersArray[index].strCategory,\n          active: true,\n          drinks: [...drinks.drinks]\n        };\n      });\n      setDrinks(initialState);\n    }).then(() => setCurrentPage(1)).catch(error => console.error(error));\n  } //Sets currentContent according to the currentPage\n\n\n  function defineCurrentContent() {\n    //Get 10 items of each drinks array of each active category\n    const paginate = (array, number) => {\n      const perPage = 10;\n      const result = array.slice(number * perPage - perPage, number * perPage);\n      return result.length === 0 ? null : result;\n    };\n\n    const content = [];\n\n    for (let category of drinks) {\n      if (filters.includes(category.filter)) {\n        const cuttedDrinks = paginate(category.drinks, currentPage);\n\n        if (cuttedDrinks) {\n          content.push({\n            filter: category.filter,\n            active: true,\n            drinks: [...cuttedDrinks]\n          });\n        }\n      }\n\n      ;\n    }\n\n    setCurrentContent(content);\n  }\n\n  ; //Apply button handler\n\n  function applyFiltersHandler() {\n    console.log(filters);\n    setDrinks(state => {\n      return state.map(category => {\n        if (filters.includes(category.filter)) return {\n          active: true,\n          filter: category.filter,\n          drinks: [...category.drinks]\n        };else return {\n          active: false,\n          filter: category.filter,\n          drinks: [...category.drinks]\n        };\n      });\n    });\n    defineCurrentContent();\n  } //Checkbox onChange handler\n\n\n  function toggleFilterHandler(e) {\n    e.persist();\n    setFilters(state => {\n      if (e.target.checked) return [...state, e.target.value];else return state.filter(name => e.target.value !== name);\n    });\n  }\n\n  ;\n}\n\nexport default App;","map":{"version":3,"sources":["/home/abbas/jsPractice/tasks/drinks-app/client/src/App.js"],"names":["React","useState","useEffect","throttle","endpoints","Header","BodyWrapper","Filters","Content","App","filters","setFilters","drinks","setDrinks","currentPage","setCurrentPage","currentContent","setCurrentContent","updateContent","updating","window","scrollY","innerHeight","document","body","clientHeight","scrollTo","top","behavior","prevPage","setInitialState","addEventListener","removeEventListener","defineCurrentContent","map","category","filter","applyFiltersHandler","toggleFilterHandler","filtersArray","fetch","then","responce","json","array","strCategory","categories","drinksPromises","push","Promise","all","drinksPromices","prom","drinksArray","initialState","index","active","catch","error","console","paginate","number","perPage","result","slice","length","content","includes","cuttedDrinks","log","state","e","persist","target","checked","value","name"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from 'react';\nimport throttle from 'lodash.throttle';\nimport './App.css';\nimport endpoints from './api/endpoints';\n\nimport Header from './components/Header';\nimport BodyWrapper from './components/BodyWrapper';\nimport Filters from './components/Filters';\nimport Content from './components/Content';\n\nfunction App() {\n  //Filters set for the checkboxes\n  const [filters, setFilters] = useState([]);\n  //All categories and drinks\n  const [drinks, setDrinks] = useState([]);\n  const [currentPage, setCurrentPage] = useState(0);\n  //Filtered and paginated content that user sees\n  const [currentContent, setCurrentContent] = useState([]);\n\n  //Update content when page scrolled to the end\n  //I see that this is unaccurate way to do updading \n  //but i hadn't mush time at the moment\n  const updateContent = throttle(() => {\n    let updating = true;\n    if (window.scrollY === 75) updating = true;\n    if ((window.scrollY + window.innerHeight) === document.body.clientHeight) {\n      if (updating) {\n        window.scrollTo({top: 0, behavior: 'smooth'});\n        setCurrentPage(prevPage => prevPage+1);\n        updating = false;\n      }\n    };\n  }, 1500);\n  //Runs at the first render and fetches all categories\n  //and drinks from api\n  useEffect(()=> {\n    setInitialState();\n    window.addEventListener('scroll', updateContent);\n    return () => {\n      window.removeEventListener('scroll', updateContent);\n    }\n  }, []);\n  //Checks the currentPage state and defines nex content\n  useEffect(() => {\n    //Check the last page and if true - return to the first one\n    if (currentPage > 10) setCurrentPage(1);\n    defineCurrentContent();\n  }, [currentPage]);\n  return (\n    <div className=\"App\">\n      <Header />\n      <BodyWrapper>\n        <Filters filters={drinks.map(category => category.filter)} \n          applyFiltersHandler={applyFiltersHandler}\n          toggleFilterHandler={toggleFilterHandler} \n        />\n        <Content drinks={currentContent} />\n      </BodyWrapper>\n    </div>\n  );\n  \n  //Set initial state at the first render\n  async function setInitialState() {\n    //To get access to the fetched filters at the nex chains\n    let filtersArray; \n    fetch(endpoints.filters)\n      .then(responce => responce.json())\n      .then(array => {\n        setFilters(array.drinks.map(filter => filter.strCategory));\n        filtersArray = array.drinks;\n        return array;\n      })\n      .then(categories => {\n        const drinksPromises = [];\n        for (let category of categories.drinks) {\n          drinksPromises.push(fetch(endpoints.drinks(category.strCategory)));\n        };\n        return Promise.all(drinksPromises);\n      })\n      .then(drinksPromices => {\n        return Promise.all(drinksPromices.map(prom => prom.json()));\n      })\n      .then(drinksArray => {\n        const initialState = drinksArray.map((drinks, index) => {\n          return {\n            filter: filtersArray[index].strCategory,\n            active: true,\n            drinks: [\n              ...drinks.drinks\n            ]\n          }\n        });\n        setDrinks(initialState);\n      })\n      .then(() => setCurrentPage(1))\n      .catch(error => console.error(error));\n  }\n  //Sets currentContent according to the currentPage\n  function defineCurrentContent() {\n    //Get 10 items of each drinks array of each active category\n    const paginate = (array, number) => {\n      const perPage = 10;\n      const result = array.slice((number * perPage) - perPage, number * perPage);\n      return result.length === 0 ? null : result;\n    }\n    \n    const content = [];\n    for (let category of drinks) {\n      if (filters.includes(category.filter)) {\n        const cuttedDrinks = paginate(category.drinks, currentPage);\n        if (cuttedDrinks) {\n          content.push({\n            filter: category.filter,\n            active: true,\n            drinks: [...cuttedDrinks]\n          });\n        }\n      };\n    }\n    setCurrentContent(content);\n  };\n  //Apply button handler\n  function applyFiltersHandler() {\n    console.log(filters);\n    setDrinks(state => {\n      return state.map(category => {\n        if (filters.includes(category.filter)) return {\n          active: true,\n          filter: category.filter,\n          drinks: [...category.drinks]\n        };\n        else return {\n          active: false,\n          filter: category.filter,\n          drinks: [...category.drinks]\n        };\n      });\n    });\n    defineCurrentContent();\n  }\n  //Checkbox onChange handler\n  function toggleFilterHandler(e) {\n    e.persist();\n    setFilters(state => {\n        if (e.target.checked) return [...state, e.target.value];\n        else return state.filter(name => e.target.value !== name);\n    });\n  };\n}\nexport default App;\n"]},"metadata":{},"sourceType":"module"}